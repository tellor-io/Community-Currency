{
  "language": "Solidity",
  "sources": {
    "contracts/Inflation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\n\nimport \"./Math.sol\";\n\n// Borrowed from https://github.com/wolflo/solidity-interest-helper.\n// Inspired by https://medium.com/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b\n// Using DSMath from DappHub https://github.com/dapphub/ds-math\n\n/**\n * @title Interest\n * @author Nick Ward\n * @dev Uses DSMath's wad and ray math to implement (approximately)\n * continuously compounding interest by calculating discretely compounded\n * interest compounded every second.\n */\ncontract Inflation is DSMath {\n    //// Fixed point scale factors\n    // wei -> the base unit\n    // wad -> wei * 10 ** 18. 1 ether = 1 wad, so 0.5 ether can be used\n    //      to represent a decimal wad of 0.5\n    // ray -> wei * 10 ** 27\n\n    // Go from wad (10**18) to ray (10**27)\n    function wadToRay(uint256 _wad) internal pure returns (uint256) {\n        return mul(_wad, 10**9);\n    }\n\n    // Go from wei to ray (10**27)\n    function weiToRay(uint256 _wei) internal pure returns (uint256) {\n        return mul(_wei, 10**27);\n    }\n\n    // The most accurate way to calculate inflation is a loop with\n    // for (let i = 0; i < secsPassed; i++) {\n    //  `tokenPrice -= tokenPrice * inflRatePerSec`\n    // }\n    // but this is too slow and expencive so this is an algorithm that has a very small precision error.\n    // The magic formula from https://medium.com/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b\n    function accrueInflation(\n        uint256 _principal,\n        uint256 _rate,\n        uint256 _age\n    ) internal pure returns (uint256) {\n        return rdiv(_principal, rpow(_rate, _age));\n    }\n\n    /**\n     * @dev Uses an approximation of continuously compounded interest\n     * (discretely compounded every second)\n     * @param _principal The principal to calculate the interest on.\n     *   Accepted in wei.\n     * @param _rate The interest rate. Accepted as a ray representing\n     *   1 + the effective interest rate per second, compounded every\n     *   second. As an example:\n     *   I want to accrue interest at a nominal rate (i) of 5.0% per year\n     *   compounded continuously. (Effective Annual Rate of 5.127%).\n     *   This is approximately equal to 5.0% per year compounded every\n     *   second (to 8 decimal places, if max precision is essential,\n     *   calculate nominal interest per year compounded every second from\n     *   your desired effective annual rate). Effective Rate Per Second =\n     *   Nominal Rate Per Second compounded every second = Nominal Rate\n     *   Per Year compounded every second * conversion factor from years\n     *   to seconds\n     *   Effective Rate Per Second = 0.05 / (365 days/yr * 86400 sec/day) = 1.5854895991882 * 10 ** -9\n     *   The value we want to send this function is\n     *   1 * 10 ** 27 + Effective Rate Per Second * 10 ** 27\n     *   = 1000000001585489599188229325\n     *   This will return 5.1271096334354555 Dai on a 100 Dai principal\n     *   over the course of one year (31536000 seconds)\n     * @param _age The time period over which to accrue interest. Accepted\n     *   in seconds.\n     * @return The new principal as a wad. Equal to original principal +\n     *   interest accrued\n     */\n    function accrueInterest(\n        uint256 _principal,\n        uint256 _rate,\n        uint256 _age\n    ) internal pure returns (uint256) {\n        return rmul(_principal, rpow(_rate, _age));\n    }\n\n    /**\n     * @dev Takes in the desired nominal interest rate per year, compounded\n     *   every second (this is approximately equal to nominal interest rate\n     *   per year compounded continuously). Returns the ray value expected\n     *   by the accrueInterest function\n     * @param _rateWad A wad of the desired nominal interest rate per year,\n     *   compounded continuously. Converting from ether to wei will effectively\n     *   convert from a decimal value to a wad.\n     *   So 5% rate should be input as yearlyRateToRay( 0.05 ether )\n     * @return 1 * 10 ** 27 + Effective Interest Rate Per Second * 10 ** 27\n     */\n\n    function yearlyRateToPerSec(uint256 _rateWad)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            add(\n                wadToRay(1 ether),\n                rdiv(wadToRay(_rateWad), weiToRay(365 * 86400))\n            );\n    }\n}\n"
    },
    "contracts/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/dapphub/ds-math\n// Added the div function from openzepeling safeMath\n\npragma solidity ^0.7.3;\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    // slither-disable-next-line incorrect-equality\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 public constant WAD = 10**18;\n    uint256 public constant RAY = 10**27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    // Not sure if this is a false positive - https://github.com/dapphub/ds-math/issues/18\n    // slither-disable-next-line weak-prng\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Main.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\n\nimport \"usingtellor/contracts/UsingTellor.sol\";\nimport \"./Token.sol\";\nimport \"./Inflation.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// The contract is also an ERC20 token which holds the collateral currency.\n// It also holds the semi stable token state inside the `token` variable.\ncontract Main is Inflation {\n    event CollateralThreshold(uint256);\n    event CollateralPriceAge(uint256);\n    event LiquidationPenatly(uint256);\n    event WithdrawCollateral(\n        address,\n        uint256 collateralAmnt,\n        uint256 collateralRatio\n    );\n    event WithdrawToken(address, uint256 tokenAmnt, uint256 collateralAmnt);\n    event Liquidate(\n        address,\n        uint256 tokensAmnt,\n        uint256 collateralAmnt,\n        uint256 collateralPenalty\n    );\n    event MintTokens(\n        address,\n        uint256 amount,\n        address to,\n        uint256 collateralRatio\n    );\n\n    address public admin = msg.sender;\n\n    Token private token;\n    Token private collateral;\n    uint256 private tknPrice = 1e18;\n\n    UsingTellor private tellor;\n\n    uint256 public collateralID; // The collateral id used to check the Tellor oracle for its USD price.\n    uint256 public collateralPriceGranularity;\n    ERC20 public collateralToken;\n    uint256 public collateralThreshold = 15e17; // 150%.\n    uint256 public collateralPriceAge = 3600; // 1h.\n    uint256 public liquidationPenatly = 0;\n\n    // The rate at which the token decreases value.\n    // 1e18 precision. 100e18 is 100%.\n    uint256 public inflRatePerSec;\n    uint256 public inflLastUpdate = block.timestamp;\n    address public inflBeneficiary; // Where to send the inflation tokens.\n\n    constructor(\n        address payable _tellorAddress,\n        address _collateralToken,\n        uint256 _collateralID,\n        uint256 _collateralPriceGranularity,\n        string memory _collateralName,\n        string memory _collateralSymbol,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint256 _inflRatePerYear,\n        address _inflBeneficiary\n    )\n        within100e18Range(_inflRatePerYear)\n        within1e18Range(_collateralPriceGranularity)\n    {\n        // TODO Check if token ID is supported by the oracle and returns the price in USD.\n        // For now assume that the contract creator knows what he is doing.\n        // The collateral ID needs to return the value in USD.\n        collateralID = _collateralID;\n        collateralToken = ERC20(_collateralToken);\n        collateralPriceGranularity = _collateralPriceGranularity;\n\n        require(_inflBeneficiary != address(0), \"benificiary address not set\");\n        inflBeneficiary = _inflBeneficiary;\n        inflRatePerSec = yearlyRateToPerSec(_inflRatePerYear);\n\n        token = new Token(_tokenName, _tokenSymbol);\n        collateral = new Token(_collateralName, _collateralSymbol);\n\n        tellor = new UsingTellor(_tellorAddress);\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"not an admin\");\n        _;\n    }\n\n    modifier within100e18Range(uint256 value) {\n        require(value > 0 && value < 100e18, \"value not within allowed limits\");\n        _;\n    }\n\n    modifier within1e18Range(uint256 value) {\n        require(value > 0 && value <= 1e18, \"value not within allowed limits\");\n        _;\n    }\n\n    function depositCollateral(uint256 wad) external onlyAdmin {\n        require(wad > 0, \"deposit amount 0\");\n        collateral.mint(msg.sender, wad);\n        require(\n            collateralToken.transferFrom(msg.sender, address(this), wad),\n            \"failed collateral deposit transfer\"\n        );\n    }\n\n    // Anyone can deposit collateral, but only admin can withdraw.\n    // Otherwise the logic for how much tokens a given collateral provider can mint becomes more complicated.\n    // If we track the balance of each collateral provider then\n    // he should be allowed to mint up to the maximum amount based on his collateral deposit share.\n    // Otherwise lets say a provider deposits 1ETH and mints all tokens to himself\n    // can drain the collateral of all providers.\n    function withdrawCollateral(uint256 wad) external onlyAdmin {\n        collateral.burn(msg.sender, wad);\n        uint256 cRatio = collateralRatio();\n        // slither-disable-next-line reentrancy-events\n        emit WithdrawCollateral(msg.sender, wad, cRatio);\n        require(\n            cRatio < collateralThreshold,\n            \"collateral utilization above the threshold\"\n        );\n        require(\n            collateralToken.transfer(msg.sender, wad),\n            \"collateral transfer fails\"\n        );\n    }\n\n    // Calculate how much percents of the total supply this sender owns and\n    // can withdraw the same amount of percents minus the liquidation penalty.\n    // Example:\n    // token totalSupply is 10000,\n    // collateral totalSupply is 1000\n    // sender owns 1000 (10% of token totalSupply)\n    // with penatly 0% sender can withdraw 100 collateral(10% of collateral total supply)\n    // with penatly 10% sender can withdraw 90 collateral\n    function liquidate() external {\n        require(\n            collateralRatio() > collateralThreshold,\n            \"collateral utilizatoin is below threshold\"\n        );\n        require(\n            token.balanceOf(msg.sender) > 0,\n            \"msg sender doesn't own any tokens\"\n        );\n\n        uint256 tknSuplyRatio =\n            wdiv(collateral.totalSupply(), token.totalSupply());\n        uint256 tokensToBurn = token.balanceOf(msg.sender);\n        uint256 collatAmt = wmul(tokensToBurn, tknSuplyRatio);\n        uint256 collatPenalty = wmul(collatAmt, liquidationPenatly);\n        uint256 collatAmntMinusPenalty = sub(collatAmt, collatPenalty);\n\n        emit Liquidate(msg.sender, tokensToBurn, collatAmt, collatPenalty);\n        token.burn(msg.sender, tokensToBurn);\n        collateral.burn(admin, collatAmt);\n\n        require(\n            collateralToken.transfer(msg.sender, collatAmntMinusPenalty),\n            \"collateral liquidation transfer fails\"\n        );\n        require(\n            collateralToken.transfer(inflBeneficiary, collatPenalty),\n            \"collateral liquidation penalty transfer fails\"\n        );\n    }\n\n    // Reduce token price by the inflation rate,\n    // increases the total supply by the inflation rate and\n    // sends the new tokens to the inflation beneficiary.\n    // slither-disable-next-line timestamp\n    function updateInflation() external {\n        uint256 secsPassed = block.timestamp - inflLastUpdate;\n        require(secsPassed > 0, \"no inflation increase yet\");\n\n        inflLastUpdate = block.timestamp;\n        tknPrice = accrueInflation(tknPrice, inflRatePerSec, secsPassed);\n\n        uint256 tokensToMint =\n            sub(\n                accrueInterest(token.totalSupply(), inflRatePerSec, secsPassed),\n                token.totalSupply()\n            );\n\n        token.mint(inflBeneficiary, tokensToMint);\n    }\n\n    function collateralRatio() public view returns (uint256) {\n        require(\n            collateral.totalSupply() > 0,\n            \"collateral total supply is zero\"\n        );\n        if (token.totalSupply() == 0) {\n            return 0;\n        }\n\n        uint256 collateralValue =\n            wmul(collateralPrice(), collateral.totalSupply());\n\n        uint256 secsPassed = block.timestamp - inflLastUpdate;\n        uint256 tokenSupplyWithInflInterest =\n            accrueInterest(token.totalSupply(), inflRatePerSec, secsPassed);\n\n        uint256 tokenValue = wmul(tokenPrice(), tokenSupplyWithInflInterest);\n\n        return add(1e18, wdiv(tokenValue, collateralValue));\n    }\n\n    // Returns the collateral price in USD upscaled to e18 precision.\n    // slither-disable-next-line timestamp\n    function collateralPrice() public view returns (uint256) {\n        (bool _didGet, uint256 _collateralPrice, ) =\n            tellor.getDataBefore(\n                collateralID,\n                block.timestamp - collateralPriceAge\n            );\n        require(_didGet, \"getting oracle price\");\n        return mul(_collateralPrice, div(1e18, collateralPriceGranularity));\n    }\n\n    // WARNING You would usually want to put this through a vote from the token holders\n    // or the collateral provider can set it very low and drain all collateral.\n    // Usually the owner should be another contract so that\n    // it is allowed to change it only after a vote from the token holders.\n    function setCollateralThreshold(uint256 wad)\n        external\n        onlyAdmin\n        within100e18Range(wad)\n    {\n        collateralThreshold = wad;\n        emit CollateralThreshold(wad);\n    }\n\n    function setCollateralPriceAge(uint256 wad) external onlyAdmin {\n        collateralPriceAge = wad;\n        emit CollateralPriceAge(wad);\n    }\n\n    // WARNING You would usually want to put this through a vote from the token holders\n    // or the admin can set it at 100% and during liquidation token holders will not receive any collateral.\n    function setLiquidationPenatly(uint256 wad)\n        external\n        onlyAdmin\n        within100e18Range(wad)\n    {\n        liquidationPenatly = wdiv(wad, 100e18); // Convert to a fraction.\n        emit LiquidationPenatly(liquidationPenatly);\n    }\n\n    // The max minted tokens can be up to the max utulization threshold.\n    // Noone should be allowed to mint above the utilizationThreshold otherwise can drain the pool.\n    function mintToken(uint256 amount, address to) external onlyAdmin {\n        token.mint(to, amount);\n        uint256 cRatio = collateralRatio();\n        // slither-disable-next-line reentrancy-events\n        emit MintTokens(msg.sender, amount, to, cRatio);\n        require(\n            cRatio < collateralThreshold,\n            \"collateral utilization above the threshold\"\n        );\n    }\n\n    // Returns the current token price in USD reduced by the current inflation.\n    function tokenPrice() public view returns (uint256) {\n        return\n            accrueInflation(\n                tknPrice,\n                inflRatePerSec,\n                block.timestamp - inflLastUpdate\n            );\n    }\n\n    function tokenTotalSupply() external view returns (uint256) {\n        return token.totalSupply();\n    }\n\n    function collateralTotalSupply() external view returns (uint256) {\n        return collateral.totalSupply();\n    }\n\n    function withdrawToken(uint256 amount) external {\n        require(amount > 0, \"amount should be greater than 0\");\n        require(token.balanceOf(msg.sender) >= amount, \"not enough balance\");\n\n        uint256 collatPrice = collateralPrice();\n        uint256 priceRatio = wdiv(tokenPrice(), collatPrice);\n        uint256 collateralAmnt = wmul(priceRatio, amount);\n\n        emit WithdrawToken(msg.sender, amount, collateralAmnt);\n        collateral.burn(admin, collateralAmnt);\n        token.burn(msg.sender, amount);\n\n        require(\n            collateralToken.transfer(msg.sender, collateralAmnt),\n            \"collateral transfer fail\"\n        );\n    }\n\n    function collateralBalance() external view returns (uint256) {\n        return collateral.balanceOf(admin);\n    }\n\n    function tokenBalanceOf(address account) external view returns (uint256) {\n        return token.balanceOf(account);\n    }\n}\n"
    },
    "usingtellor/contracts/UsingTellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nimport \"../Interface/ITellor.sol\";\n\n/**\n * @title UserContract\n * This contracts creates for easy integration to the Tellor System\n * by allowing smart contracts to read data off Tellor\n */\ncontract UsingTellor {\n    ITellor private tellor;\n\n    /*Constructor*/\n    /**\n     * @dev the constructor sets the storage address and owner\n     * @param _tellor is the TellorMaster address\n     */\n    constructor(address payable _tellor) {\n        tellor = ITellor(_tellor);\n    }\n\n    /**\n     * @dev Retreive value from oracle based on requestId/timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retreive data/value from\n     * @return uint value for requestId/timestamp submitted\n     */\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.retrieveData(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to looku p\n     * @param _timestamp is the timestamp to look up miners for\n     * @return bool true if requestId/timestamp is under dispute\n     */\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\n        public\n        view\n        returns (bool)\n    {\n        return tellor.isInDispute(_requestId, _timestamp);\n    }\n\n    /**\n     * @dev Counts the number of values that have been submited for the request\n     * @param _requestId the requestId to look up\n     * @return uint count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getNewValueCountbyRequestId(_requestId);\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _requestId is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint timestamp\n     */\n\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getTimestampbyRequestIDandIndex(_requestId, _index);\n    }\n\n    /**\n     * @dev Allows the user to get the latest value for the requestId specified\n     * @param _requestId is the requestId to look up the value for\n     * @return ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\n     * @return value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getCurrentValue(uint256 _requestId)\n        public\n        view\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\n        uint256 _time =\n            tellor.getTimestampbyRequestIDandIndex(_requestId, _count - 1);\n        uint256 _value = tellor.retrieveData(_requestId, _time);\n        if (_value > 0) return (true, _value, _time);\n        return (false, 0, _time);\n    }\n\n    // slither-disable-next-line calls-loop\n    function getIndexForDataBefore(uint256 _requestId, uint256 _timestamp)\n        public\n        view\n        returns (bool found, uint256 index)\n    {\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\n        if (_count > 0) {\n            uint256 middle;\n            uint256 start = 0;\n            uint256 end = _count - 1;\n            uint256 _time;\n\n            //Checking Boundaries to short-circuit the algorithm\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, start);\n            if (_time >= _timestamp) return (false, 0);\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, end);\n            if (_time < _timestamp) return (true, end);\n\n            //Since the value is within our boundaries, do a binary search\n            while (true) {\n                middle = (end - start) / 2 + 1 + start;\n                _time = tellor.getTimestampbyRequestIDandIndex(\n                    _requestId,\n                    middle\n                );\n                if (_time < _timestamp) {\n                    //get imeadiate next value\n                    uint256 _nextTime =\n                        tellor.getTimestampbyRequestIDandIndex(\n                            _requestId,\n                            middle + 1\n                        );\n                    if (_nextTime >= _timestamp) {\n                        //_time is correct\n                        return (true, middle);\n                    } else {\n                        //look from middle + 1(next value) to end\n                        start = middle + 1;\n                    }\n                } else {\n                    uint256 _prevTime =\n                        tellor.getTimestampbyRequestIDandIndex(\n                            _requestId,\n                            middle - 1\n                        );\n                    if (_prevTime < _timestamp) {\n                        // _prevtime is correct\n                        return (true, middle - 1);\n                    } else {\n                        //look from start to middle -1(prev value)\n                        end = middle - 1;\n                    }\n                }\n                //We couldn't found a value\n                //if(middle - 1 == start || middle == _count) return (false, 0);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Allows the user to get the first value for the requestId before the specified timestamp\n     * @param _requestId is the requestId to look up the value for\n     * @param _timestamp before which to search for first verified value\n     * @return _ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(uint256 _requestId, uint256 _timestamp)\n        public\n        view\n        returns (\n            bool _ifRetrieve,\n            uint256 _value,\n            uint256 _timestampRetrieved\n        )\n    {\n        (bool _found, uint256 _index) =\n            getIndexForDataBefore(_requestId, _timestamp);\n        if (!_found) return (false, 0, 0);\n        uint256 _time =\n            tellor.getTimestampbyRequestIDandIndex(_requestId, _index);\n        _value = tellor.retrieveData(_requestId, _time);\n        //If value is diputed it'll return zero\n        if (_value > 0) return (true, _value, _time);\n        return (false, 0, 0);\n    }\n}\n"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// The contract is also an ERC20 token which holds the collateral currency.\n// It also holds the semi stable token state inside the `token` variable.\ncontract Token is ERC20 {\n    function burn(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory n, string memory s) ERC20(n, s) {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "usingtellor/Interface/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\ninterface ITellor {\n    /**\n     * @dev Helps initialize a dispute by assigning it a disputeId\n     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n     * invalidated value information to POS voting\n     * @param _requestId being disputed\n     * @param _timestamp being disputed\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n     * requires 5 miners to submit a value.\n     */\n    function beginDispute(\n        uint256 _requestId,\n        uint256 _timestamp,\n        uint256 _minerIndex\n    ) external;\n\n    /**\n     * @dev Allows token holders to vote\n     * @param _disputeId is the dispute id\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n     */\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\n\n    /**\n     * @dev tallies the votes.\n     * @param _disputeId is the dispute id\n     */\n    function tallyVotes(uint256 _disputeId) external;\n\n    /**\n     * @dev Allows for a fork to be proposed\n     * @param _propNewTellorAddress address for new proposed Tellor\n     */\n    function proposeFork(address _propNewTellorAddress) external;\n\n    /**\n     * @dev Add tip to Request value from oracle\n     * @param _requestId being requested to be mined\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\n     * mine the onDeckQueryHash, or the api with the highest payout pool\n     */\n    function addTip(uint256 _requestId, uint256 _tip) external;\n\n    /**\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId the apiId being mined\n     * @param _value of api query\n     *\n     */\n    function submitMiningSolution(\n        string calldata _nonce,\n        uint256 _requestId,\n        uint256 _value\n    ) external;\n\n    /**\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId is the array of the 5 PSR's being mined\n     * @param _value is an array of 5 values\n     */\n    function submitMiningSolution(\n        string calldata _nonce,\n        uint256[5] calldata _requestId,\n        uint256[5] calldata _value\n    ) external;\n\n    /**\n     * @dev Allows the current owner to propose transfer control of the contract to a\n     * newOwner and the ownership is pending until the new owner calls the claimOwnership\n     * function\n     * @param _pendingOwner The address to transfer ownership to.\n     */\n    function proposeOwnership(address payable _pendingOwner) external;\n\n    /**\n     * @dev Allows the new owner to claim control of the contract\n     */\n    function claimOwnership() external;\n\n    /**\n     * @dev This function allows miners to deposit their stake.\n     */\n    function depositStake() external;\n\n    /**\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n     * can withdraw the stake\n     */\n    function requestStakingWithdraw() external;\n\n    /**\n     * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n     */\n    function withdrawStake() external;\n\n    /**\n     * @dev This function approves a _spender an _amount of tokens to use\n     * @param _spender address\n     * @param _amount amount the spender is being approved for\n     * @return true if spender appproved successfully\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    /**\n     * @dev Allows for a transfer of tokens to _to\n     * @param _to The address to send tokens to\n     * @param _amount The amount of tokens to send\n     * @return true if transfer is successful\n     */\n    function transfer(address _to, uint256 _amount) external returns (bool);\n\n    /**\n     * @dev Sends _amount tokens to _to from _from on the condition it\n     * is approved by _from\n     * @param _from The address holding the tokens being transferred\n     * @param _to The address of the recipient\n     * @param _amount The amount of tokens to be transferred\n     * @return True if the transfer was successful\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool);\n\n    /**\n     * @dev Allows users to access the token's name\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @dev Allows users to access the token's symbol\n     */\n    function symbol() external pure returns (string memory);\n\n    /**\n     * @dev Allows users to access the number of decimals\n     */\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @dev Getter for the current variables that include the 5 requests Id's\n     * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip\n     */\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _challenge,\n            uint256[5] memory _requestIds,\n            uint256 _difficutly,\n            uint256 _tip\n        );\n\n    /**\n     * @dev Getter for the top tipped 5 requests Id's\n     * @return _requestIds the 5 requestsId\n     */\n    function getTopRequestIDs()\n        external\n        view\n        returns (uint256[5] memory _requestIds);\n\n    /**\n     * @dev Getter for the 5 requests Id's next in line to get mined\n     * @return idsOnDeck tipsOnDeck  the 5 requestsId\n     */\n    function getNewVariablesOnDeck()\n        external\n        view\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\n\n    /**\n     * @dev Updates the Tellor address after a proposed fork has\n     * passed the vote and day has gone by without a dispute\n     * @param _disputeId the disputeId for the proposed fork\n     */\n    function updateTellor(uint256 _disputeId) external;\n\n    /**\n     * @dev Allows disputer to unlock the dispute fee\n     * @param _disputeId to unlock fee from\n     */\n    function unlockDisputeFee(uint256 _disputeId) external;\n\n    /**\n     * @param _user address\n     * @param _spender address\n     * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n     */\n    function allowance(address _user, address _spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\n     * @param _user address\n     * @param _amount uint of amount\n     * @return true if the user is alloed to trade the amount specified\n     */\n    function allowedToTrade(address _user, uint256 _amount)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Gets balance of owner specified\n     * @param _user is the owner address used to look up the balance\n     * @return Returns the balance associated with the passed in _user\n     */\n    function balanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev Queries the balance of _user at a specific _blockNumber\n     * @param _user The address from which the balance will be retrieved\n     * @param _blockNumber The block number when the balance is queried\n     * @return The balance at _blockNumber\n     */\n    function balanceOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev This function tells you if a given challenge has been completed by a given miner\n     * @param _challenge the challenge to search for\n     * @param _miner address that you want to know if they solved the challenge\n     * @return true if the _miner address provided solved the\n     */\n    function didMine(bytes32 _challenge, address _miner)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Checks if an address voted in a given dispute\n     * @param _disputeId to look up\n     * @param _address to look up\n     * @return bool of whether or not party voted\n     */\n    function didVote(uint256 _disputeId, address _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev allows Tellor to read data from the addressVars mapping\n     * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\n     * These are examples of how the variables are saved within other functions:\n     * addressVars[keccak256(\"_owner\")]\n     * addressVars[keccak256(\"tellorContract\")]\n     * return address\n     */\n    function getAddressVars(bytes32 _data) external view returns (address);\n\n    /**\n     * @dev Gets all dispute variables\n     * @param _disputeId to look up\n     * @return bytes32 hash of dispute\n     * @return bool executed where true if it has been voted on\n     * @return bool disputeVotePassed\n     * @return bool isPropFork true if the dispute is a proposed fork\n     * @return address of reportedMiner\n     * @return address of reportingParty\n     * @return address of proposedForkAddress\n     *    uint of requestId\n     *    uint of timestamp\n     *    uint of value\n     *    uint of minExecutionDate\n     *    uint of numberOfVotes\n     *    uint of blocknumber\n     *    uint of minerSlot\n     *    uint of quorum\n     *    uint of fee\n     * @return int count of the current tally\n     */\n    function getAllDisputeVars(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        );\n\n    /**\n     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n     */\n    function getCurrentVariables()\n        external\n        view\n        returns (\n            bytes32,\n            uint256,\n            uint256,\n            string memory,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Checks if a given hash of miner,requestId has been disputed\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n     * @return uint disputeId\n     */\n    function getDisputeIdByDisputeHash(bytes32 _hash)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n     * @param _disputeId is the dispute id;\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the disputeUintVars under the Dispute struct\n     * @return uint value for the bytes32 data submitted\n     */\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @return value for timestamp of last proof of work submited\n     * @return true if the is a timestamp for the lastNewValue\n     */\n    function getLastNewValue() external view returns (uint256, bool);\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @param _requestId being requested\n     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n     */\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool);\n\n    /**\n     * @dev Gets blocknumber for mined timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up blocknumber\n     * @return uint of the blocknumber which the dispute was mined\n     */\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return the 5 miners' addresses\n     */\n    function getMinersByRequestIdAndTimestamp(\n        uint256 _requestId,\n        uint256 _timestamp\n    ) external view returns (address[5] memory);\n\n    /**\n     * @dev Counts the number of values that have been submited for the request\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n     * request so far\n     * @param _requestId the requestId to look up\n     * @return uint count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for the specified requestQ index\n     * @param _index to look up in the requestQ array\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByRequestQIndex(uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for requestId based on timestamp\n     * @param _timestamp to check requestId\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByTimestamp(uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for requestId based on the queryHash\n     * @param _request is the hash(of string api and granularity) to check if a request already exists\n     * @return uint requestId\n     */\n    function getRequestIdByQueryHash(bytes32 _request)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for the requestQ array\n     * @return the requestQ arrray\n     */\n    function getRequestQ() external view returns (uint256[51] memory);\n\n    /**\n     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n     * for the requestId specified\n     * @param _requestId to look up\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the apiUintVars under the requestDetails struct\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\n     */\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the API struct variables that are not mappings\n     * @param _requestId to look up\n     * @return string of api to query\n     * @return string of symbol of api to query\n     * @return bytes32 hash of string\n     * @return bytes32 of the granularity(decimal places) requested\n     * @return uint of index in requestQ array\n     * @return uint of current payout/tip for this requestId\n     */\n    function getRequestVars(uint256 _requestId)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            bytes32,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev This function allows users to retireve all information about a staker\n     * @param _staker address of staker inquiring about\n     * @return uint current state of staker\n     * @return uint startDate of staking\n     */\n    function getStakerInfo(address _staker)\n        external\n        view\n        returns (uint256, uint256);\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestampt to look up miners for\n     * @return address[5] array of 5 addresses ofminers that mined the requestId\n     */\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256[5] memory);\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _requestID is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint timestamp\n     */\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the uintVars under the TellorStorageStruct struct\n     * This is an example of how data is saved into the mapping within other functions:\n     * self.uintVars[keccak256(\"stakerCount\")]\n     * @return uint of specified variable\n     */\n    function getUintVar(bytes32 _data) external view returns (uint256);\n\n    /**\n     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n     */\n    function getVariablesOnDeck()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            string memory\n        );\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return bool true if requestId/timestamp is under dispute\n     */\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Retreive value from oracle based on timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retreive data/value from\n     * @return value for timestamp submitted\n     */\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter for the total_supply of oracle tokens\n     * @return uint total supply\n     */\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}